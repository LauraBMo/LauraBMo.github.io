#+TITLE: Introducció a Julia: Algebraic Numbers

* Julia
** "... easy to write code that's nearly as fast as C."
- Kind of mix between
  - Slow dynamic language (Python, Matlab...) però *fàcil de programar*
  - *Fast* Static language (C, Frotran...) però no tant fàcil de programar.
- To produce actual fast code: see [[https://docs.julialang.org/en/v1/manual/performance-tips/][Performance tips]]

  Slogan: "the compiler should be able to predict objects' type"

** Multiple dispatch
*** Types
Every object/value is of some type.
- Primitive types: data consisting of plain bits (Float64, Int16, Char, Bool...)
- (Mutable) Composite types: (mutable) collection of fields treated as a single value:

#+begin_src julia-vterm :session
 struct AlgebraicNumber
     minpoly::Vector
     approx::BigFloat
 end

x = AlgebraicNumber([0,1], 0) # zero
y = AlgebraicNumber([-2,0,1], 1.41) # sqrt(2)
x.minpoly
y.approx
#+end_src

   Obs: /0 and 1.14 are Float64, the constructor "AlgebraicNumber" convert them to BigFloat/

   Or mutable (e.g., [[file:~/.julia/dev/HomotopyContinuation/src/path_result.jl][PathResult]])

#+begin_src julia-vterm :session
mutable struct AlgebraicNumber # Bad idea
     minpoly::Vector
     approx::BigFloat
 end
#+end_src

- Parametric types:
  
 #+begin_src julia-vterm :session
 struct AlgebraicNumber{T} where {T}
     minpoly::Vector{T}
     approx::BigFloat
 end
#+end_src

- Abstract types

  Types with no fields, to create a type hierarchy/graph (e.g., [[https://upload.wikimedia.org/wikipedia/commons/4/40/Type-hierarchy-for-julia-numbers.png][Numbers hierarchy]])

  All types are subtypes of "Any" 
  
 #+begin_src julia-vterm :session
 supertype(AlgebraicNumber)
 struct AlgebraicNumber{T<:Integer} <: Number
     minpoly::Vector{T}
     approx::BigFloat
 end
#+end_src

#+RESULTS:

*** Methods

- A function is a collection of methods

#+begin_src julia-vterm :session
methods(*)
#+end_src

#+begin_src julia-vterm :session
f(x::Float64, y::Float64) = 2x + y

f(2.0, 3.0)
f(2.0, 3)

# A more generic implementation
f(x::Number, y::Number) = 2x

# The generic implementation
f(x,y) = 2*x.-y

# Parametric methods
same_type(x, y) = false
same_type(x::T, y::T) where {T} = true

same_type(1, 2)
same_type(1, 2.0)
same_type("foo", "bar")
#+end_src

- There is no performance penalty for generic implementations:
 

#+begin_src julia-vterm :session
# Inatall a package
# import Pkg; Pkg.add(LinearAlgebra)
# Load a package
using LinearAlgebra
using Nemo
# using NoExistsPackage

function adjugate(M, i, j)
    n = size(M, 1)
    I = trues(n)
    J = trues(n)
    I[i] = J[j] = 0
    return (-1)^(i + j) * det(M[J,I])
end

M = randn(10,10)
# Run multiple times, see deff. between first run and others
@time adjugate(M,3,4);
N = rand(Int, 10,10)
typeof(M)
typeof(N)
# Run multiple times, see deff. between first run and others
@time adjugate(N,3,4)
# There is again longer first run because adjugate is compiled again
# for the type Matrix{Int64}
#+end_src

#+RESULTS:

** Type stabilty

#+begin_src julia-vterm :session
function t1(n)
    s = 0
    t = 1
    for i in 1:n
        s += s/i
        t = div(t, i)
    end
    return t
end

function t2(n)
    s = 0.0
    t = 1
    for i in 1:n
        s += s/i
        t = div(t, i)
    end
    return t
end

using BenchmarkTools
@benchmark t1(10000000)
@benchmark t2(10000000)

@code_native t1(100)
@code_native t2(100)

@code_warntype t1(100)
@code_warntype t2(100)
#+end_src

#+RESULTS:

* OSCAR

[[https://oscar.computeralgebra.de/documentation/]]

** Guessing algebraic numbers:

- Recover $\alpha\in \bar{\mathbb{Q}}$, from:
  - numerical value
  - upper bound degree of the minimal polynomial 

    (Visit [[https://www.juliahomotopycontinuation.org/][HomotopyContinuation.jl]], "docs" and "crash curse")

#+begin_src julia-vterm :session
using HomotopyContinuation
using Nemo

# HomotopyContinuation code
@var x

F = x^5-2
result = HomotopyContinuation.solve(System([F]))

solutions(result)
a = real_solutions(result)
certify(System([F]), a)

α = certified_solution_interval.(certificates(certify(System([F]), a)))[1][1]

# Nemo code
CC = AcbField(128);
CC = ComplexField(64)

β = CC(string(real(α)), string(imag(α)))
guess(QQBar, β, 6)
#+end_src

** Polymake.jl

#+begin_src julia-vterm :session
using Polymake

"""

    cone_positiveorthant(n)

Return the cone (Polymake big object) corresponding to the nonnegative orthant of R^n.

"""
function cone_positiveorthant(n)
    rays = cat(ones(Int, n)..., dims=(1, 2))
    return Polymake.polytope.Cone(INPUT_RAYS=rays)
end

"""

    cone_vectorspace(M::AbstractMatrix{T}) where {T <: Integer}

Return the cone (Polymake big object) corresponding to vector space generated by the columns of M.

"""
function cone_vectorspace(M::AbstractMatrix{T}) where {T <: Integer}
    rays = transpose(hcat(M, -M))
    return Polymake.polytope.Cone(INPUT_RAYS=rays)
end

"""

    cone_positivenullspace(N::AbstractMatrix{T}) where {T<:Integer}

Return the cone (Polymake big object) intersection of the nonnegative orthant and the nullspace of `N`.

"""
function cone_positivenullspace(N::AbstractMatrix{T}) where {T <: Integer}
    nullspace = Nemo.nullspace_right_rational(N)
    return Polymake.polytope.intersection(cone_positiveorthant(size(N, 2)), cone_vectorspace(nullspace))
end

function Nemo.nullspace_right_rational(N::AbstractArray{T}) where {T<:Integer}
    Nnemo = Nemo.matrix(Nemo.FlintZZ, N)
    r, U = Nemo.nullspace_right_rational(Nnemo)
    M = U[:,1:r]
    return T.(Array(M))
end

function raysof(cone, conename="")
    length(conename) > 0 && print("Computing rays of $(conename), it may take some time.\n")
    return Rational.(transpose(Array(cone.RAYS)))
end
# Vectors are columns not= columns matrices
N = [1 1] # empty
N = [1 -1] # [1 1]

raysof.(cone_positivenullspace.([N, M, ...]))
#+end_src

* AlgebraicNumbers

[[file:~/.julia/dev/AlgebraicNumbers/README.md]]

[[file:~/.julia/dev/AlgebraicNumbers/bostan2006.pdf]]

Implement Arithmetics.jl?

** Basic structure
#+begin_src julia-vterm :session
"""
        AlgebraicNumber

Structure for algebraic numbers. It consists of
   - the minimal polynomial of the number, a vector of fmpz,
   - complex ball containing a certified root of minpoly.


     AlgebraicNumber(x)

Converts `x` to `AlgebraicNumber`, where `x` is of some Julia exact number type,
`Union{S, Rational{S}, Complex{S}, Complex{Rational{S}}} where {S <: Integer}`.
"""
struct AlgebraicNumber <: Number
    minpoly::Vector{fmpz}
    approx::Acb
    # Arblib uses RefVal DEFAULT_PRECISION[] to set new Arb/Acb....
end

getminpoly(an::AlgebraicNumber) = an.minpoly
getapprox(an::AlgebraicNumber) = an.approx

Base.hash(an::AlgebraicNumber, h::UInt) = hash((an.minpoly, an.apprx), h)
Base.show(io::IO, an::AlgebraicNumber) = print(io, "≃" * Arblib.string_nice(an.approx, 20))

const IntOrRat = Union{Integer,Rational}

# Create Algebraic Numbers from Julia exact numbers.
AlgebraicNumber(x::T) where {T <: IntOrRat} = AlgebraicNumber([-numerator(x), denominator(x)], x)

function AlgebraicNumber(x::Complex{T}) where {T <: Integer}
    return isreal(x) ? AlgebraicNumber(real(x)) :
        AlgebraicNumber([imag(x)^2 + real(x)^2, -2 * real(x), one(T)], x)
end

function AlgebraicNumber(x::Complex{Rational{T}}) where {T <: Integer}
    return isreal(x) ? AlgebraicNumber(real(x)) :
        AlgebraicNumber(RatVec([imag(x)^2 + real(x)^2, -2 * real(x), one(T)]), x)
end
#+end_src

** Rarional Vectors

#+begin_src julia-vterm :session
"""
    RatVec{T}

Vectors of eltype `T`.

Used to avoid type piracy in converting them to vectors
of some integer of type multiplying by the lcm of the denominators.
"""
struct RatVec{T} <: AbstractVector{T}
	vec::Vector{T}
end

getvector(v::RatVec) = v.vec

# Base.length(v::RatVec) = Base.length(getvector(v))
# Base.size(v::RatVec) = Base.size(getvector(v))

# Base.eltype(v::RatVec{T}) where T = T

# Base.IndexStyle(::Type{<:RatVec}) = Base.IndexLinear()
# Base.getindex(v::RatVec, i::Int) = Base.getindex(getvector(v), i)

Base.convert(::Type{Vector{T}}, v::RatVec{S}) where {T,S} =
    T.(lcm(denominator.(getvector(v))) .* getvector(v))

#+end_src

** Newton
#+begin_src julia-vterm :session
function poly_to_Newton(coeffs::Vector{T}, N, R, x) where {T}
	# first, make monic.
	mcoeffs = moniccoeffs(coeffs)
	D = degree(mcoeffs)

	# initialize power series polynomials
	A = R(reverse(derivative(mcoeffs)))
	B = R(reverse(mcoeffs))

	b0 = R(poly_inv_from_coeffs(reverse(mcoeffs), D))
	c  = mullow(A, b0, D)

	r = R()
	x_power = R(1)
	x_d = x^D

	step(C) = -mullow(shift_right(B * C, D), b0, D)
	for j = 0:Int(floor(N / D))
		r += c * x_power
		x_power *= x_d
		c = step(c)
	end
	return Nemo.coeffs(r)
end

function Newton_to_poly(N::Vector{T}, D=length(N)) where {T}
	# special case
	n = length(N)
	out = T[0,1]
	if N != [1]
		c = zeros(T, max(D, n)) # The first D~n entries are zero.
		c[end] = one(T)
		for k = 1:n - 1
			next_c = -sum(N[2:(k + 1)] .* c[(end - k + 1):end]) // k
			c[end - k] = next_c
		end
		out = c
	end
	return out
end

#+end_src
** Composed Operations
#+begin_src julia-vterm :session


# # Hadamard (element-wise) product of two polynomials

"""
    factorials(n)

List of the n first factorial numbers, the coefficients of exponential series.
"""
factorials(n) = factorial.(Nemo.FlintZZ.(0:n))
coeffsexp(n) = 1 .// factorials(n)
coeffsinvexp(n) = factorials(n)

Hadamard(coeffs1, coeffs2) = prod.(zip(coeffs1, coeffs2))

# composed product of two polynomials, given as coeffs p and q
function composed_product(coeffsp::Vector{T}, coeffsq::Vector{T}) where {T}
	# compute newton series
	n = degree(coeffsp) * degree(coeffsq) + 1
	R, x = Nemo.PolynomialRing(Nemo.FlintQQ, "x")
	# eats coeffsp::Vector{fmpz}; returns iterator coeffs of poly in R
	coeffsA = poly_to_Newton(coeffsp, n, R, x)
	coeffsB = poly_to_Newton(coeffsq, n, R, x)

	# Hadamard product of the newton series and convert back to polynomial
	coeffsAB = Hadamard(coeffsA, coeffsB)
	coeffspq = Newton_to_poly(coeffsAB, n + 1)

	# convert to integer and return
	return convert(Vector{T}, RatVec(coeffspq))
end

composed_product(p,q) = composed_product(promote(p, q)...)

# composed sum of two polynomials, given as coeffs p and q
function composed_sum(coeffsp::Vector{T}, coeffsq::Vector{T}) where {T}
	# compute newton series
	n = degree(coeffsp) * degree(coeffsq) + 1
	R, x = Nemo.PolynomialRing(Nemo.FlintQQ, "x")
	coeffsA = poly_to_Newton(coeffsp, n, R, x)
	coeffsB = poly_to_Newton(coeffsq, n, R, x)

	# Multiply newton series
	m = Nemo.coeffs(mullow(
		R(Hadamard(coeffsA, coeffsexp(degree(coeffsA)))),
		R(Hadamard(coeffsB, coeffsexp(degree(coeffsB)))),
		n + 1
	))
	# Convert back to polynomial
	pq = Newton_to_poly(Hadamard(m, coeffsinvexp(degree(m))), n + 1)
	# convert to integer and return
	return convert(Vector{T}, RatVec(pq))
end

#+end_src

** Certify

#+begin_src julia-vterm :session
Base.big(z::Acb) = Complex(BigFloat(Arblib.realref(z)), BigFloat(Arblib.imagref(z)))
Base.big(n::fmpz) = BigInt(n)

certify_approx(poly::Vector{fmpz}, approx::Acb) = certify_approx(big.(poly), big.(approx))

function certify_approx(poly::Vector{T}, approx::S) where {T <: Integer,S <: Number}
    out = Acb(0)
    if !(poly ==  T[0,1]) # problem with certification approx
        t = Variable(:t)
        F = System([vec_to_poly(poly, t)], variables=[t])
        out = certify_approx(F, approx)
    end
    return out
end

function certify_approx(F::System, approx::S) where {S <: Number}
    # Maybe use HomotopyContinuation.certify_solution
    certificate = first(certificates(certify(F, [approx]; show_progress=false)))
    return is_certified(certificate) ?
        first(certified_solution_interval(certificate)) :
        throw("Error certifying solution!")
end
#+end_src
